/**
 * Solution Thought: Note that two list are sorted! Can use recursive solution intuitively!
 * 
 * Use a newhead refers to current smallest node in two lists, and recursively update newhead and make (newhead = smallest node!)
 * 
 * Base case 
 */

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        /* corner cases */
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        ListNode newhead = null;
        if (l1.val < l2.val) {
            newhead = l1; // newhead and l1 point to same element 
            newhead.next = mergeTwoLists(l1.next, l2); // l1 -> l1.next here, in the next recursion, new l1 is current l1.next 
        } else {
            newhead = l2;
            newhead.next = mergeTwoLists(l2.next, l1);
        }
        
        return newhead; // return the list generated by newhead!
    }
}
